{"pages":[],"posts":[{"title":"es6","text":"ES6项目构建 let和const命令let命令let声明 123456{ let a=10;//let声明的变量只在它所在的代码块有效 var b=1;}console.log(b);// console.log(a);//报错 let应用 1234567891011for(let i=0;i&lt;10;i++){}//console.log(i);//i不能在外面引用var a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6]();//如果是var声明，则会输出10；如果是let声明，则会输出6//let声明中，每次循环的i其实都是一个新的变量 let不支持变量提升 只要块级作用域内存在let命令，它所声明的变量就“绑定”了这块区域，不再受外部的影响 1234567891011var temp=123;if(true){ temp='abc';//会报错，因为下面的let声明了temp，所以这里的temp和外面的就没有关系了， //但是此处的赋值在声明之前，还没有声明就赋值会报错 let temp; /*ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。*/ //称为暂时性死区}typeof x; // 报错let x;//let不予许重复声明 块级作用域外层作用域无法读取内层作用域的变量 1234{{{{ {let insane = 'Hello World'} console.log(insane); // 报错}}}}; 内层作用域可以定义外层作用域的同名变量 1234{{{{ let insane = 'Hello World'; {let insane = 'Hello World'}}}}}; 作用：使的获得广泛应用的立即执行函数表达式（IIFE）不再必要了 12345678910// IIFE 写法(function () { var tmp = ...; ...}());// 块级作用域写法{ let tmp = ...; ...} do 表达式块级作用域本质上是语句，没有返回值，所以在外部没法或许执行结果 可以通过do表达式获取块级作用于中的最后执行的表达式的值。 1234let x = do{ let t = f(); t * t + 1;} const 命令const 声明一个只读的常量。一旦声明，常量的值就不能改变。—所以常量一旦声明就必须立即初始化，不能留到以后赋值const 的作用域与let命令相同：只在声明所在的块级作用域内有效const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const实际保证的，并不是变量的值不得改动，而是变量指向的哪个地址不得改动如：const foo={}；foo存的是地址，这个地址指向一个对象，这个对象本身是可变的，故可添加属性foo.prop=123;但是不可把foo指向另一个地址：foo = {}//错误 ————-让对象冻结的方法（不可改变属性）————— 12const foo=Object freeze({});foo.prop=123;//常规模式下，此行代码不起作用。 严格模式下会报错 ————-让对象彻底冻结的方法————————-注：对象的属性有可能还是对象，那么对象的属性就有可能有自己的属性，那么对象的属性也要被冻结 ***使用回调函数 12345678var constantize = (obj)=&gt;{ Object freeze(obj); Object keys(obj).forEach((key,i)=&gt;{ if(typeof obj[key]==='object'){ constantize(obj[key]); } });} es6声明变量的6种方法var function let const import class es5只有前两种 顶层对象的属性顶层对象：window（浏览器环境），global（Node环境） window.a=1; 和 a=1； 是一样的，即顶层对象属性和全局变量是一样的 这是JavaScript设计的败笔之一，ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 123456var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined global对象有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象 垫片库（system.global）模拟了这个提案，可以在所有环境中拿到global 12import getGlobal from 'system.global';const global = getGlobal(); 变量的解构赋值数组的解构赋值1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 不完全解构： 12let [x, y] = [1, 2, 3];// x 为1， y为2let [a, [b], d] = [1, [2, 3], 4];//a 为 1，b为 2，d为4 //下面情况将会报错，右边必须为数组(可遍历的结构——Iterator 接口)形式 123let [foo] = 1;let [foo] = undefined;let [foo] = {}; 对于 Set 结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // &quot;a&quot; 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 12345678910function* fibs() { let a = 0; let b = 1; while (true) { yield a; [a, b] = [b, a + b]; }}let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值解构赋值允许指定默认值 123let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 1234let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。==惰性求值==：即只有在用到的时候才会求值默认值可以引用解构赋值的其他变量，但该变量必须已经声明 123let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的解构赋值数组的解构赋值是有顺序的，但是对象的解构赋值是无需的，变量名和属性同名才能获取到正确的值。 123456789101112131415let { bar: bar, foo: foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot;};// 可以简写为let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot;};foo // &quot;aaa&quot;bar // &quot;bbb&quot;let {foo: xiao , baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot;};baz // undefinedxiao // &quot;aaa&quot;//真正被赋值的是后者foo // error : foo is not definedlet obj = { first: 'hello', last: 'world' };let { first: f, last: 1 } = obj;f // 'hello'l // 'world' 与数组一样，结构也可以用于嵌套结构的对象 123456789101112131415let obj = { p: [ 'Hello', { y: 'World' } ]};let { p: [x, { y }] } = obj;x // &quot;Hello&quot;y // &quot;World&quot;//如果写法如下：那么p既是模式又是变量let { p, p: [x, { y }] } = obj;x // &quot;Hello&quot;y // &quot;World&quot;p // [&quot;Hello&quot;, {y: &quot;World&quot;}] 一个嵌套的例子： 12345let obj = {};let arr = [];({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true});// 此处必须加小括号，否则会报错obj // {prop:123}arr // [true] 对象的结构也可以设置默认值，默认值生效的条件是严格等于undefined 如果结构失败，变量的值等于undefined 123var { x = 1, y = 2 } = { x: undefined, y: null };x // 1y // null 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量 123let {sin, cos, tan} = Math;Math.sin // 一个sin functionsin // 一个sin function 直接将Math中的方法给了sin 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象 1234567const [a, b, c, d, e] = 'hello';a // &quot;h&quot;e // &quot;o&quot;//类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值let {length : len} = 'hello';len // 5 数值和布尔值得解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，无法转化成对象，将会报错 12345678let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // truelet { prop: x } = undefined; // TypeErrorlet { prop: y } = null; // TypeError 函数参数的解构赋值1234567function add([x, y]){ return x + y;}add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题建议只要有可能，就不要在模式中放置圆括号 不能使用圆括号的情况1.变量声明语句 1234567//全部报错let [(a)] = [1];let {x: (c)} = {};let ({x: c}) = {};let {(x: c)} = {};let {(x): c} = {};let { o: ({ p: p }) } = { o: { p: 2 } }; 2.函数参数 1234// 报错function f([(z)]) { return z; }// 报错function f([z,(x)]) { return x; } 3.赋值语句模式 123456// 全部报错({ p: a }) = { p: 42 };([a]) = [5];// 报错[({ p: a }), { x: c }] = [{}, {}]; 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 123[(b)] = [3]; // 正确({ p: (d) } = {}); // 正确[(parseInt.prop)] = [3]; // 正确 用途1.交换变量的值 123let x = 1;let y =2;[x, y] = [y, x]; 2.从函数返回多个值直接取值就可以 1234567function example() { return { foo: 1, bar: 2 };}let { foo, bar } = example(); 3.函数参数的定义4.提取JSON数据 12345678let jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 5.函数参数的默认值 1234567891011jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config}) { // ... do stuff}; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句6.遍历Map结构 123456789101112131415161718const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) { console.log(key + &quot; is &quot; + value);}// first is hello// second is world//如果只想获取键名，或者只想获取键值，可以写成下面这样。// 获取键名for (let [key] of map) { // ...}// 获取键值for (let [,value] of map) { // ...} 7.输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); 字符串的扩展字符的Unicode表示法codePointAt()String.fromCodePoint()字符串的遍历器接口es6为字符串添加了遍历器接口,而且增加的for…of循环识别码点 1234567891011let text = String.fromCodePoint(0x20BB7);for (let i of text) { console.log(i);}// &quot;𠮷&quot;for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// &quot; &quot;// &quot; &quot; at()es5中的charAt方法可以返回字符串指定位置的字符，但是不识别码点大于0xFFFF的字符。es6提供了at()方法，可以实现这一要求 61234'abc'.charAt(0) //&quot;a&quot;'𠮷'.charAt(0) // &quot;\\uD842&quot;'abc'.at(0) // &quot;a&quot;'𠮷'.at(0) // &quot;𠮷&quot; normalize()includes()、startWith()、endsWithincludes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 612345678910let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true//这三个方法都支持第二个参数，表示开始搜索的位置。s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 61'hello'.repeat(2) // &quot;hellohello&quot; padStart(),padEnd()字符串补全长度的功能9","link":"/2017/11/14/es6/"},{"title":"GULP","text":"简介1、Gulp是一个开源的JavaScript开源自动化工具2、Gulp应用于前后端代码管理的一种工具3、Gulp是基于Node.js和NPM应用的构建工具4、Gulp主要用于处理耗时及重复的任务5、Gulp可以解决上百种的任务 例如：压缩代码 合并代码等 gulp作用1、压缩代码2、合并代码3、压缩图片4、Sass、Less转换5、…… 原理1、基于Node.js中的数据流2、Gulp主要使用pipe事件输入及输出3、插件独立使用 安装步骤1、安装Node环境2、通过 npm install -g gulp 安装全局3、初始化package.json4、在项目文件中安装gulp","link":"/2017/11/17/gulp/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/06/hello-world/"},{"title":"underscore源码解析","text":"","link":"/2017/12/19/underscore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"git","text":"原文链接","link":"/2017/12/06/git/"},{"title":"VUE","text":"==vue.js 轻量级的MVVM框架数据驱动+组件化的开发== 基本指令1v-if是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：v-if=”expression” 2v-show根据表达式的真假来删除和插入元素 v-if=”expression” 3可以用v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别。v-if和v-else连用时，不执行else时，else里面的HTML不渲染v-if和v-show连用时，不执行else时，else里面的HTML渲染，只是display：none隐藏了 4v-for=”item in items” items是一个数组，item是当前被遍历的数组元素。总是key配合v-for使用 12345&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; 5v-bind 指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute–专门用来绑定属性），例如：v-bind:width=&quot;&quot; v-bind:argument=&quot;expression&quot; 简写形式如下：:argument=&quot;expression&quot; 另外可以绑定类名用法1： :class=&quot;[className1,className2,className3]&quot; 其中，className1、2、3是数据 放在data中的用法2： :class=&quot;{className1:true,className2:false}&quot; 其中，className1、2是真正的类名用法3： :class=&quot;json&quot; json是data里面的json可以绑定style :style=&quot;[c]&quot; c是json形式的数据 :style=&quot;[c,d]&quot; c和d都是json形式的数据，多个样式的写法 :style=&quot;json&quot; json是data中的数据 6v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听&lt;a&gt;元素的点击事件：&lt;a v-on:click=&quot;doSomething&quot;&gt;v-on 有简写形式，如下：&lt;a @click=&quot;doSomething&quot;&gt; 7.模板数据更新模板变化-->v-text=\"msg\" 后面的方法可以防止闪烁 1{{*msg}} 数据只绑定一次 1{{{msg}}} 将HTML转译输出–&gt;v-html=”msg” 后面的方法可以防止闪烁，前面的方法v2.0已经删掉了 8.过滤器过滤模板数据 系统提供一些过滤器: 12{{msg| filterA}}{{msg| filterA | filterB}}","link":"/2017/11/15/vue/"},{"title":"","text":"被wx-open-launch-weapp折磨累了，也就不废话了，直接上关键点： ps:其他细节不赘述，自行百度，有很多案例 引入jweixin.js，需要1.6.0版本 http://res2.wx.qq.com/open/js/jweixin-1.6.0.js 设置wx.config 设置：openTagList:['wx-open-launch-weapp']（必须有，跳转小程序）设置：jsApiList:['chooseImage', 'previewImage']（必须有，不然安卓不显示） vue中忽略wx-open-launch-weapp标签检测 在main.js中添加：Vue.config.ignoredElements = ['wx-open-launch-weapp'] 在vue页面中添加wx-open-launch-weapp标签 在vue的视图页： 12345678910111213141516171819&lt;wx-open-launch-weapp id=&quot;launch-btn&quot; username=&quot;gh_xxxxxxx&quot; path=&quot;pages/order-tab/order-tab.html&quot; @launch=&quot;sucFun&quot; @error=&quot;errFun&quot; &gt; &lt;script type=&quot;text/wxtag-template&quot;&gt; &lt;style&gt;.guideBtn{width: 347px; height: 50px; background-color: #ff6611; border-radius: 2px; color: #fff; font-size: 16px; line-height: 50px; text-align: center;}&lt;/style&gt; &lt;div class=&quot;guideBtn&quot;&gt;去注册&lt;/div&gt; &lt;/script&gt;&lt;/wx-open-launch-weapp&gt; 在vue的methods中： 12sucFun(msg) { console.log(msg) },errFun(msg) { console.log(msg) } 另外，在vue中也可以使用v-html去绑定，例如： 在vue视图中： 1&lt;div id=&quot;wxLaunchBox&quot; v-html=&quot;weappDom&quot;&gt;&lt;/div&gt; 在vue的script中（可放在created中）： 123456789101112131415161718192021this.weappDom = ` &lt;wx-open-launch-weapp id=&quot;launch-btn&quot; username=&quot;gh_xxxxxx&quot; path=&quot;pages/order-tab/order-tab.html&quot; @launch=&quot;sucFun&quot; @error=&quot;errFun&quot; &gt; &lt;script type=&quot;text/wxtag-template&quot;&gt; &lt;style&gt;.guideBtn{width: 347px; height: 50px; background-color: #ff6611; border-radius: 2px; color: #fff; font-size: 16px; line-height: 50px; text-align: center;}&lt;/style&gt; &lt;div class=&quot;guideBtn&quot;&gt;去注册&lt;/div&gt; &lt;/script&gt; &lt;/wx-open-launch-weapp&gt; ` 注意：vue页面中，可以使用&lt;script type=&quot;text/wxtag-template&quot;&gt;&lt;/script&gt;进行包裹标签普通html页面中，使用&lt;template&gt;&lt;/template&gt;进行包裹样式中不可添加position:fixed，position:absoulte样式，不然按钮不展示 环境 微信开发工具和真机测试结果可能不一样，一定要用真机测试安卓和ios测试结果也可能不同，都要测试6. 小程序的web-view不支持wx-open-launch-weapp 所以在h5页面中使用wx-open-launch-weapp跳转A小程序，如果将此h5通过webview的方式嵌入B小程序，这个功能将失效，按钮也不会展示 此情况还是采用长按识别小程序码吧！（直接放上小程序码图片&lt;img src=&quot;xxx&quot; alt=&quot;小程序码&quot; /&gt;就可以，系统自带长按识别功能）——官方的规格还没有明确说支持这个功能，但是可以使用。 如果直接使用img放小程序码页不识别，那就再退而求其次吧，可以使用官方文档提供的图片预览的功能： 1234wx.previewImage({ current: '', // 当前显示图片的http链接（注意：是在线链接，不是本地） urls: [] // 需要预览的图片http链接列表（注意：是在线链接，不是本地）&gt;}); 点击之后，出现预览的小程序码或二维码界面，然后长按识别 如果还是不可以，那就更换需求或交互方式。总之，大家自己想办法吧🤪 ps： 尽自己的绵薄之力让大家少走点坑，其他的坑大家慢慢踩吧🐷。说实话，微信相关开发是真的坑，及其不友好😭😭😭（痛苦三连~~~）","link":"/2021/07/07/wx-open-launch-weapp/"},{"title":"原生JS","text":"工作线程（webWorker）简介：web worker是HTML5引入的一个工作线程的概念，是运行在后台的JavaScript，独立于其他脚本。允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。 简而言之，就是允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。从而，可以用webWorker来处理一些比较耗时的计算。","link":"/2017/11/18/%E5%8E%9F%E7%94%9Fjs%E6%9C%89%E8%B6%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"设计模式","text":"单例模式 单例模式保证类只有一个实例，并提供一个访问她的全局访问点 123456function getSingle(fn){ let result return function (){ return result || (result=fn.apply(this,arguments)) }} 策略模式 解决一个问题的多个方法，将每种方法独立封装起来，相互可以转换 一个基于策略模式的程序至少由两部分组成，一个是一组策略类，策略类封装了具体的算法，并负责具体的计算过程，一个是环境类，环境类接受客户的请求，随后把请求委托给某个策略类策略模式的一个使用场景：表单验证，将不同验证规则封装成一组策略，避免了多重条件判断语句一句经典的话: 在函数作为一等对象的语言中，策略模式是隐性的，策略就是值为函数的变量例子: 12345678910111213const S = (salary)=&gt;{ return salary * 4}const A = (salary)=&gt;{ return salary * 3}const B = (salary)=&gt;{ return salary * 2}const calculate = (fun,salary)=&gt;{ return fun(salary)}calculate(S,1000) 代理模式 代理模式为一个对象提供一个代用品或占位符，以便控制对它的访问 不直接和本体进行交互，而是在中间加入一层代理，代理来处理一些不需要本体做的操作 123456789101112131415161718192021var myImage=function(){ var imgNode=document.createElement('img') document.body.appendChild(imgNode) return { setImg(src){ imgNode.src=src } }}var proxyImg=function(){ var img =new Image() img.onload=function(){ myImage.setSrc(this.src) } return { setImg(src){ myImage.setSrc(‘loading.png’) img.src=src } }} 代理的意义对单一职责原则的一种表现，单一职责原则指的是，一个函数或类应该只负责一件事，如何一个函数职责太多，等于把这些职责耦合在了一起，当一部分需要改动时，很有可能就影响到了函数的其他部分 观察者和发布订阅模式观察者和发布、订阅模式使程序的两部分不必紧密耦合在一起，而是通过通知的方式来通信 观察者模式 一个对象维持一系列依赖于它的对象，当对象状态发生改变时主动通知这些依赖对象 这里注意是对象直接管理着依赖列表，这点也是观察者模式和发布、订阅模式的主要区别 1234567891011121314151617class Subject{ constructor(){ this.observers=[] } add(observer){ this.observers.push(observer) } notify(data){ for(let observer of this.observers){ observer.update(data) } }}class Observer{ update(){ }} 发布订阅模式该模式在主题和观察者之间加入一层管道，使得主题和观察者不直接交互，发布者将内容发布到管道，订阅者订阅管道里的内容，目的是避免订阅者和发布者之间产生依赖关系12345678910111213141516171819202122232425262728293031323334353637383940class Pubsub{ constuctor(){ this.pubsub={} this.subId=-1 } publish(topic,data){ if(!this.pubsub[topic]) return const subs=this.pubsub[topic] const len=subs.length while(len--){ subs[len].update(topic,data) } } /** * topic {string} * update {function} */ subscribe(topic,update){ !this.pubsub[topic] &amp;&amp; (this.pubsub[topic]=[]) this.subId++ this.pubsub[topic].push({ token:this.subId, update }) } unsubscribe(token){ for(let topic in this.pubsub){ if(this.pubsub.hasOwnProperty(topic)){ const current=this.pubsub[topic] for(let i=0,j=current.length;i&lt;j;i++){ if(current[i].token==token){ current.splice(i,1) return token } } } } return this }} 命令模式 命令模式的命令指的是一个执行某些特定事情的指令 命令模式最常见的使用场景是：有时候需要向某些对象发送请求，但是不知道请求的接受者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，是使得请求发送者和接受者消除彼此之间的耦合关系命令模式的由来，其实是回调函数的一个面向对象的替代品一句话来说，命令模式就是用一个函数来包裹一个具体的实现，这个函数统一定义了一个 execute 方法来调用具体的实现方法，而请求者只要和这个命令函数交流就行 享元模式 享元模式顾名思义，共享一些单元，用于优化重复、缓慢及数据共享效率较低的代码 应用：一是用于数据层，处理内存中保存的大量相似对象的共享数据，二是用于 DOM 层，事件代理在享元模式中，有个有关两个状态的概念 - 内部和外部内部状态存储于对象内部，可以被一些对象共享，独立于具体的场景，通常不会变外部状态根据场景而变化剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组成一个完整的对象使用享元模式的几个步骤：以书中文件上传的例子描述1.剥离外部状态 12345678910111213class Upload { constructor(type) { this.uploadType = type } delFile(id) { uploadManager.setExternalState(id, this) //这里就是组装外部状态来使共享对象变成一个具体的对象 if (this.fileSize &lt; 3000) { //直接删除 return } //弹窗询问确认删除？ }} 2.使用工厂进行对象实例化 1234567891011var UploadFactory = (function() { const flyWeightObjs = {} return { create(uploadType) { if (flyWeightObjs[uploadType]) { return flyWeightObjs[uploadType] } return flyWeightObjs[uploadType] = new Upload(uoloadType) } }})() 3.使用管理器封装外部状态 1234567891011121314151617181920212223var uploadManager = (function() { var uploadDatabase = {} return { add(id, uploadType, fileSize, fileName) { var flyWeightObj = UploadFactory.create(uploadType) //那个被共享的对象 //创建结点... //删除操作 dom.onclick = function() { flyWeightObj.delFile(id) //这个共享在步骤1中会被组合，可以看到，只有在删除操作的时候，我们才需要那些外部状态 } uploadDatabase[id] = { fileName, fileSize, dom } return flyWeightObj }， setExternalState(id, flyWeight) { var externalState = uploadDatabase[id] Object.assign(flyWeight, externalState) } }})() 责任链模式 将一个请求以此传递给多个函数，若请求符合当前函数要求，则当前函数处理，否则，传给下一个 很好很强大责任链模式可以很好的避免大量的 if,else if,else 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (Function.prototype.chainAfter) { throw new Error('the chainAfter method already exist')} else { Function.prototype.chainAfter = function(fn) { return (...args) =&gt; { const ret = this.apply(this, [...args, () =&gt; { return fn &amp;&amp; fn.apply(this, args) }]) if (ret === 'NEXT') { return fn &amp;&amp; fn.apply(this, args) } return ret } }}/* * example * class Test{ * * test(...args){ * alert('test') * return 'NEXT' * } * * test1(...args){ * * setTimeout(()=&gt;{ * alert('test1') * args.pop()() * }) * } * * test2(...args){ * alert('test2') * } * * $onInit(){ * const chain = this.test.bind(this) * .chainAfter(this.test1.bind(this)) * .chainAfter(this.test2.bind(this)) * chain(1,2,3) * } * } * */ 装饰者模式 在不改变原有函数或对象功能的基础上，给它们新加功能 用 AOP 装饰函数 123456789101112131415161718192021if (Function.prototype.before) { throw new Error('the before method already exist')} else { Function.prototype.before = function(beforefn) { return () =&gt; { if (beforefn.apply(this, arguments)) { this.apply(this, arguments) } } }}if (Function.prototype.after) { throw new Error('the after method already exist')} else { Function.prototype.after = function(afterfn) { return () =&gt; { this.apply(this, arguments) afterfn.apply(this, arguments) } }} 状态模式 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类 要点：将状态封装成独立的函数，并将请求委托给 当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化电灯的例子：一个按钮控制电灯的开关，按一下是开，再按一下是关初始实现： 1234567891011121314151617181920class Light { constructor() { this.state = 'off', this.button = null } init() { //创建按钮结点 ..... this.button.onClick = () =&gt; { this.btnPressed() } } btnPressed() { if (this.state == 'off') { this.state = 'on' } else { this.state = 'off' } }} 这段代码的缺点就是不易扩展，当要加入一种闪动的状态时，就要修改 btnPressed 中的代码 使用状态模式改写 123456789101112131415161718192021222324252627class Light { constructor() { this.state = FSM.off, this.button = null } init() { //创建按钮结点 ..... this.button.onClick = () =&gt; { this.state.btnPressed.call(this) } }}const FSM = { on: { btnPressed() { //处理 this.state = FMS.on } }, off: { btnPressed() { //处理 this.state = FMS.off } }} 点击查看原文","link":"/2017/11/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"工具类","slug":"工具类","link":"/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"},{"name":"js","slug":"web/js","link":"/categories/web/js/"},{"name":"工具","slug":"web/工具","link":"/categories/web/%E5%B7%A5%E5%85%B7/"},{"name":"vue","slug":"web/vue","link":"/categories/web/vue/"},{"name":"设计模式(web)","slug":"web/设计模式-web","link":"/categories/web/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-web/"}]}